/*
* 代理模式：给某一个对象提供一个代理，并由代理对象控制对原对象的引用。（为其他对象提供一种代理以控制这个对象的访问）
* 优点：（1）代理模式能够将客户与真正被调用的对象分离（协调调用者与被调用者），降低了耦合度；
（2）客户端可以通过代理与多个目标对象交互，目标对象的修改和扩展客户端并不感知，扩展性和维护性强
（3）各种代理模式：
远程代理：使得客户端可以访问在远程机上的对象，远程机可以具有更好的计算性能与处理速度，可以快速相应并处理客户端请求；
虚拟代理：可以使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度；
保护代理：可以控制对真实对象的使用权限；
缺点：
（1）在客户端和真正目标对象之间增加代理对象，请求速度有可能会变慢；
（2）增加代理会使系统复杂度变高;
*应用：（1）代理服务器，通过代理服务器访问无法访问的服务器；
（2）可以在代理服务器实现负载均衡、数据缓存；
常见的代理模式：
（1）远程代理（Remote）：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是同一台主机中，也可以是在另一台主机中；
（2）虚拟代理（Virtual）:如果需要创建一个资源消耗比较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只有需要时才会被真正创建；如打开网页时，先看到文字，比较大的图片一张张下载。
（3）保护代理（Protect or Access）,控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。
其他的代理：缓冲代理、防火墙代理、同步化代理。
*/

#include<iostream>
using namespace std;

class Subject //Subject（抽象主题角色） 
{//声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。
public:
	virtual void Request() = 0;
};

class ConSubject :public Subject //RealSubject（真实主题角色）
{//定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。
public:
	void Request()
	{
		cout << "ConSubject" << endl;
	}
};

class Proxy//Proxy（代理主题角色）
{//代理主题角色通过关联关系引用真实主题角色，因此可以控制和操纵真实主题对象；
//代理主题角色中提供一个与真实主题角色相同的接口（以在需要时代替真实主题角色），同时还可以在调用对真实主题对象的操作之前或之后增加新的服务和功能；
public:
	Proxy() {}
	Proxy(Subject* sub) { m_sub = sub; }//代理主题角色中定义了一个真实主题角色对象
	~Proxy() { delete m_sub; }
	void Request()
	{
		cout << "Proxy" << endl;
		m_sub->Request();//代理主题角色调用 真实角色的业务方法
	}
private:
	Subject* m_sub;
};

int main()
{
	Subject* sub = new ConSubject();
	Proxy* p = new Proxy(sub);
	p->Request();
}